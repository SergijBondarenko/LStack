#ifndef LSTACK_H
#define LSTACK_H

// Для хранения данных используются массивы. Размер массива указывается в
// конструкторе и может быть изменен в зависимости от требований. Больший
// размер массивов увеличивает количество резервируемой памяти, но уменьшает
// количестов обращений к системе за выделением нового куска памяти. 
// В случае если структуре данных требуется дополнительная память под
// новые элементы происходит не увеличение размера массива (так как при этом
// потребуется скопировать данные в новый увеличеный массив), а создание нового
// массива. В результате элементы находятся сразу в нескольких массивах
// указаного в конструкторе размера (array_size). Для манипулирования этими
// массивами указатели на них помещаются в связный список.
// В случае удаления большого количества элементов из структуры некоторые из
// массивов могут оказаться пустыми. В таком случае память выделеная под них
// освобождается, но происходит это только тогда когда в массиве что находится
// под ним окажется определенное количество свободных элементов (min_size).
// В этой реализации min_size равна половине array_size, тоесть пустой массив 
// удаляется тогда когда в предудущем массиве есть хотя бы половина свободного
// места. Тогда получается что максимальное количество "лишней" памяти
// зарезервированой стеком равно 1.5 * память занимаемая массивом

template <typename T>
class LStack
{
 public:
    explicit LStack(int);
    ~LStack();
    void push(T);                   //Помещает элемент в стек
    T pop();                        //Извлекает элемент из стека
    
    int size() { return size_; }        //Количество элементов в стеке
    bool empty() { return size_ == 0; } //Возвращает true когда стек пустой

 private:
 
    int size_;                   //Количество элементов в стеке
    const int array_size;       //Размер массивов
    const int min_size;         //Количество свободных элементов после которого происходит
                                //удаление предыдущего массива
    
    struct Node                 //элемент связного списка с ссылками на массивы
    {
        T* array;               //ссылка на массив с данными
        Node* next;
        Node(T* a, Node* n) : array(a), next(n) {}
    };
    
    Node* first;                //Ссылка на элемент связного списка в котором находится вершина стека
    
    int current;                //индекс вершины стека - индекс по которому будет помещен следующий
                                //добавленый в стек элемент. Он может быть отрицательным - это значит
                                //что массив который в данный момент находится на вершине стека полностью
                                //пустой, новые данные помещаются в масив перед ним. Пустой масив будет удален
                                //если в предудущем массиве окажется достаточно места.
    
    void expand();              //Добавление в стек нового массива для хранения данных.
    void collapse();            //Удаление пустого массива
};
//Конструктор (аргумент - количество элементов в массивах используемых для хранения данных)
template <typename T>
LStack<T>::LStack(int sz = 100)
    : size_(0)
    , array_size(sz)
    , min_size(array_size/2)
    , first(new Node(new T[array_size], 0))
    , current(0)
{}
//Деструктор
template <typename T>
LStack<T>::~LStack()
{
    while (first != 0)
    {
        delete[] first->array;
        Node* next = first->next;
        delete first;
        first = next;
    }
}
//Помещает в стек элемент item. Если индекс вершины стека current отрицателен
//то данные помещаются не в массив на которые указывает первый элемент связного
//списка, а в массив второго - в нем еще есть свободные места
template <typename T>
void LStack<T>::push(T item)
{
    if (current == array_size) expand();
    if (current < 0) first->next->array[array_size + current] = item;
    else first->array[current] = item;
    ++current;
    ++size_;
}
//Удаляет из стека и возвращает элемент который находится на вершине стека.
template <typename T>
T LStack<T>::pop()
{
    if (size_ == 0) return 0;
    if (current < -min_size) collapse();
    T result;
    if (current > 0) result = first->array[current - 1];
    else result = first->next->array[array_size + current - 1];
    --current;
    --size_;
    return result;
}
//Добавляет к стеку новый массив для хранения данных
template <typename T>
void LStack<T>::expand()
{
    Node * new_node = new Node(new T[array_size], first);
    first = new_node;
    current = 0;
}
//Удаляет пустой массив (и элемент связного списка который на него указывал)
template <typename T>
void LStack<T>::collapse()
{
    Node * old = first;
    first = old->next;
    delete[] old->array;
    delete old;
    current = array_size + current;
}
#endif